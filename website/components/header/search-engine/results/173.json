{"type":"doc","filename":"devonfw-guide_devon4j.wiki_guide-json.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_guide-json.asciidoc_json-and-inheritance","title":"JSON and Inheritance","breadcrumbs":["Java","General","JSON"],"text":"JSON and Inheritance\n\n\n\n\nWarning\n\n\nHey there! Seems like you are still using the documentation of our legacy Java repository. Since it wonâ€™t be maintained anymore, we recommend you to checkout the new Java page here.\nIf you are using inheritance for your objects mapped to JSON then polymorphism can not be supported out-of-the box. So in general avoid polymorphic objects in JSON mapping. However, this is not always possible.\nHave a look at the following example from our sample application:\n\n\n\n\n\n\n\n\nFigure 8. Transfer-Objects using Inheritance\n\n\nNow assume you have a REST service operation as Java method that takes a ProductEto as argument. As this is an abstract class the server needs to know the actual sub-class to instantiate.\nWe typically do not want to specify the classname in the JSON as this should be an implementation detail and not part of the public JSON format (e.g. in case of a service interface). Therefore we use a symbolic name for each polymorphic subtype that is provided as virtual attribute @type within the JSON data of the object:\n\n\n\n\n\n\n\nTherefore you add configuration code to the constructor of ApplicationObjectMapperFactory. Here you can see an example from the sample application:\n\n\n\n\n\n\n\nWe use setBaseClasses to register all top-level classes of polymorphic objects. Further we declare all concrete polymorphic sub-classes together with their symbolic name for the JSON format via addSubtypes.\n\n\n\n"}