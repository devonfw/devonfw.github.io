{"type":"doc","filename":"guide-jpa.asciidoc.html","anchor":"guide-jpa.asciidoc_relationships","title":"Relationships","breadcrumbs":["Java","General","Java Persistence API"],"text":"Relationships\n\nn:1 and 1:1 Relationships\n\nEntities often do not exist independently but are in some relation to each other. For example, for every period of time one of the StaffMember’s of the restaurant example has worked, which is represented by the class WorkingTime, there is a relationship to this StaffMember.\n\n\nThe following listing shows how this can be modeled using JPA:\n\n\n\n\n\n\n\nTo represent the relationship, an attribute of the type of the corresponding entity class that is referenced has been introduced. The relationship is a n:1 relationship, because every WorkingTime belongs to exactly one StaffMember, but a StaffMember usually worked more often than once.\nThis is why the @ManyToOne annotation is used here. For 1:1 relationships the @OneToOne annotation can be used which works basically the same way. To be able to save information about the relation in the database, an additional column in the corresponding table of WorkingTime is needed which contains the primary key of the referenced StaffMember. With the name element of the @JoinColumn annotation it is possible to specify the name of this column.\n\n\n\n1:n and n:m Relationships\n\nThe relationship of the example listed above is currently an unidirectional one, as there is a getter method for retrieving the StaffMember from the WorkingTime object, but not vice versa.\n\n\nTo make it a bidirectional one, the following code has to be added to StaffMember:\n\n\n\n\n\n\n\nTo make the relationship bidirectional, the tables in the database do not have to be changed. Instead the column that corresponds to the attribute staffMember in class WorkingTime is used, which is specified by the mappedBy element of the @OneToMany annotation. Hibernate will search for corresponding WorkingTime objects automatically when a StaffMember is loaded.\n\n\nThe problem with bidirectional relationships is that if a WorkingTime object is added to the set or list workingTimes in StaffMember, this does not have any effect in the database unless\nthe staffMember attribute of that WorkingTime object is set. That is why the devon4j advices not to use bidirectional relationships but to use queries instead. How to do this is shown here. If a bidirectional relationship should be used nevertheless, appropriate add and remove methods must be used.\n\n\nFor 1:n and n:m relations, the devon4j demands that (unordered) Sets and no other collection types are used, as shown in the listing above. The only exception is whenever an ordering is really needed, (sorted) lists can be used.\nFor example, if WorkingTime objects should be sorted by their start time, this could be done like this:\n\n\n\n\n\n\n\nThe value of the @OrderBy annotation consists of an attribute name of the class followed by asc (ascending) or desc (descending).\n\n\nTo store information about a n:m relationship, a separate table has to be used, as one column cannot store several values (at least if the database schema is in first normal form).\nFor example if one wanted to extend the example application so that all ingredients of one FoodDrink can be saved and to model the ingredients themselves as entities (e.g. to store additional information about them), this could be modeled as follows (extract of class FoodDrink):\n\n\n\n\n\n\n\nInformation about the relation is stored in a table called BILL_ORDER that has to have two columns, one for referencing the Bill, the other one for referencing the Order. Note that the @JoinTable annotation is not needed in this case because a separate table is the default solution here (same for n:m relations) unless there is a mappedBy element specified.\n\n\nFor 1:n relationships this solution has the disadvantage that more joins (in the database system) are needed to get a Bill with all the Orders it refers to. This might have a negative impact on performance so that the solution to store a reference to the Bill row/entity in the Order’s table is probably the better solution in most cases.\n\n\nNote that bidirectional n:m relationships are not allowed for applications based on devon4j. Instead a third entity has to be introduced, which \"represents\" the relationship (it has two n:1 relationships).\n\n\n\nEager vs. Lazy Loading\n\nUsing JPA it is possible to use either lazy or eager loading. Eager loading means that for entities retrieved from the database, other entities that are referenced by these entities are also retrieved, whereas lazy loading means that this is only done when they are actually needed, i.e. when the corresponding getter method is invoked.\n\n\nApplication based on devon4j are strongly advised to always use lazy loading. The JPA defaults are:\n\n\n\n\n@OneToMany: LAZY\n\n\n@ManyToMany: LAZY\n\n\n@ManyToOne: EAGER\n\n\n@OneToOne: EAGER\n\n\n\n\nSo at least for @ManyToOne and @OneToOne you always need to override the default by providing fetch = FetchType.LAZY.\n\n\n\n\n\nImportant\n\n\nPlease read the performance guide.\n\n\n\n\n\n\nCascading Relationships\n\nFor relations it is also possible to define whether operations are cascaded (like a recursion) to the related entity.\nBy default, nothing is done in these situations. This can be changed by using the cascade property of the annotation that specifies the relation type (@OneToOne, @ManyToOne, @OneToMany, @ManyToOne). This property accepts a CascadeType that offers the following options:\n\n\n\n\nPERSIST (for EntityManager.persist, relevant to inserted transient entities into DB)\n\n\nREMOVE (for EntityManager.remove to delete entity from DB)\n\n\nMERGE (for EntityManager.merge)\n\n\nREFRESH (for EntityManager.refresh)\n\n\nDETACH (for EntityManager.detach)\n\n\nALL (cascade all of the above operations)\n\n\n\n\nSee here for more information.\n\n\n\nTypesafe Foreign Keys using IdRef\n\nFor simple usage you can use Long for all your foreign keys.\nHowever, as an optional pattern for advanced and type-safe usage, we offer IdRef.\n\n\n\n\n"}