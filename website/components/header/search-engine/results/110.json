{"type":"doc","filename":"devonfw-guide_devon4j.wiki_devon4j.asciidoc_layers.html","anchor":"devonfw-guide_devon4j.wiki_guide-logic-layer.asciidoc","title":"Logic Layer","breadcrumbs":["Java","Spring","Layers"],"text":"Logic Layer\n\nThe logic layer is the heart of the application and contains the main business logic.\nAccording to our business architecture, we divide an application into components.\nFor each component, the logic layer defines different use-cases. Another approach is to define a component-facade, which we do not recommend for future application. Especially for quarkus application, we want to simplify things and highly suggest omitting component-facade completely and using use-cases only.\nIt is very important that you follow the links to understand the concept of use-case in order to properly implement your business logic.\n\n\nResponsibility\n\nThe logic layer is responsible to implement the business logic according to the specified functional demands and requirements.\nTherefore, it creates the actual value of the application. The logic layer is responsible for invoking business logic in external systems.\nThe following additional aspects are also included in its responsibility:\n\n\n\n\nvalidation\n\n\nauthorization\n\n\ntransaction-handling (in addition to service layer).\n\n\n\n\n\nSecurity\n\nThe logic layer is the heart of the application. It is also responsible for authorization and hence security is important in this current case. Every method exposed in an interface needs to be annotated with an authorization check, stating what role(s) a caller must provide in order to be allowed to make the call. The authorization concept is described here.\n\n\nDirect Object References\n\nA security threat are Insecure Direct Object References. This simply gives you two options:\n\n\n\n\navoid direct object references\n\n\nensure that direct object references are secure\n\n\n\n\nEspecially when using REST, direct object references via technical IDs are common sense. This implies that you have a proper authorization in place. This is especially tricky when your authorization does not only rely on the type of the data and according to static permissions but also on the data itself. Vulnerabilities for this threat can easily happen by design flaws and inadvertence. Here is an example from our sample application:\n\n\nWe have a generic use-case to manage BLOBs. In the first place, it makes sense to write a generic REST service to load and save these BLOBs. However, the permission to read or even update such BLOB depends on the business object hosting the BLOB. Therefore, such a generic REST service would open the door for this OWASP A4 vulnerability. To solve this in a secure way, you need individual services for each hosting business object to manage the linked BLOB and have to check permissions based on the parent business object. In this example the ID of the BLOB would be the direct object reference and the ID of the business object (and a BLOB property indicator) would be the indirect object reference.\n\n\n\n\n\n\nWarning\n\n\nHey there! Seems like you are still using the documentation of our legacy Java repository. Since it won’t be maintained anymore, we recommend you to checkout the new Java page here.\n\n\n\n\n\n\n\n\nComponent Facade\n\n\n\n\nNote\n\n\nOur recommended approach for implementing the logic layer is use-cases\n\n\n\n\n\nFor each component of the application, the logic layer defines a component facade.\nThis is an interface defining all business operations of the component.\nIt carries the name of the component («Component») and has an implementation named «Component»Impl (see implementation).\n\n\nAPI\n\nThe component facade interface defines the logic API of the component and has to be business oriented.\nThis means that all parameters and return types of all methods from this API have to be business transfer-objects, datatypes (String, Integer, MyCustomerNumber, etc.), or collections of these.\nThe API may also only access objects of other business components listed in the (transitive) dependencies of the business-architecture.\n\n\nHere is an example how such an API may look like:\n\n\n\n\n\n\n\n\nImplementation\n\nThe implementation of an interface from the logic layer (a component facade or a use-case) carries the name of that interface with the suffix Impl and is annotated with @Named.\nAn implementation typically needs access to the persistent data.\nThis is done by injecting the corresponding repository (or DAO).\nAccording to data-sovereignty, only repositories of the same business component may be accessed directly.\nFor accessing data from other components the implementation has to use the corresponding API of the logic layer (the component facade). Further, it shall not expose persistent entities from the domain layer and has to map them to transfer objects using the bean-mapper.\n\n\n\n\n\n\n\nAs you can see, entities (BookingEntity) are mapped to corresponding ETOs (BookingEto).\nFurther details about this can be found in bean-mapping.\n\n\n\n\n\n\nWarning\n\n\nHey there! Seems like you are still using the documentation of our legacy Java repository. Since it won’t be maintained anymore, we recommend you to checkout the new Java page here.\n\n\n\n\n\n\n\n\nUseCase\n\nA use-case is a small unit of the logic layer responsible for an operation on a particular entity (business object).\nWe leave it up to you to decide whether you want to define an interface (API) for each use-case or provide an implementation directly.\n\n\nFollowing our architecture-mapping (for classic and modern project), use-cases are named Uc«Operation»«BusinessObject»[Impl]. The prefix Uc stands for use-case and allows to easily find and identify them in your IDE. The «Operation» stands for a verb that is operated on the entity identified by «BusinessObject».\nFor CRUD we use the standard operations Find and Manage that can be generated by CobiGen. This also separates read and write operations (e.g. if you want to do CQSR, or to configure read-only transactions for read operations).\n\n\nIn our example, we choose to define an interface for each use-case. We also use *To to refer to any type of transfer object. Please follow our guide to understand more about different types of transfer object e.g. Eto, Dto, Cto\n\n\nFind\n\nThe UcFind«BusinessObject» defines all read operations to retrieve and search the «BusinessObject».\nHere is an example:\n\n\n\n\n\n\n\n\nManage\n\nThe UcManage«BusinessObject» defines all CRUD write operations (create, update and delete) for the «BusinessObject».\nHere is an example:\n\n\n\n\n\n\n\n\nCustom\n\nAny other non CRUD operation Uc«Operation»«BusinessObject» uses any other custom verb for «Operation».\nTypically, such custom use-cases only define a single method.\nHere is an example:\n\n\n\n\n\n\n\n\nImplementation\n\nThe implementation should carry its own name and the suffix Impl and is annotated with @Named and @ApplicationScoped. It will need access to the persistent data which is done by injecting the corresponding repository (or DAO). Furthermore, it shall not expose persistent entities from the data access layer and has to map them to transfer objects using the bean-mapper. Please refer to our bean mapping, transfer object and dependency injection documentation for more information.\nHere is an example:\n\n\n\n\n\n\n\nThe use-cases can then be injected directly into the service.\n\n\n\n\n\n\n\n\nInternal use case\n\nSometimes, a component with multiple related entities and many use-cases needs to reuse business logic internally.\nOf course, this can be exposed as an official use-case API but this will imply using transfer-objects (ETOs) instead of entities. In some cases, this is undesired e.g. for better performance to prevent unnecessary mapping of entire collections of entities.\nIn the first place, you should try to use abstract base implementations providing reusable methods the actual use-case implementations can inherit from.\nIf your business logic is even more complex and you have multiple aspects of business logic to share and reuse but also run into multi-inheritance issues, you may also just create use-cases that have their interface located in the impl scope package right next to the implementation (or you may just skip the interface). In such a case, you may define methods that directly take or return entity objects.\nTo avoid confusion with regular use-cases, we recommend to add the Internal suffix to the type name leading to Uc«Operation»«BusinessObject»Internal[Impl].\n\n\n\n\n\n\n\nWarning\n\n\nHey there! Seems like you are still using the documentation of our legacy Java repository. Since it won’t be maintained anymore, we recommend you to checkout the new Java page here.\n\n\n\n\n\n\n\n\n\n"}