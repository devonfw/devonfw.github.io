{"type":"doc","filename":"master-mrchecker.asciidoc_test-framework-modules.html","anchor":"master-mrchecker.asciidoc_web-api-module","title":"Web API Module","breadcrumbs":["Tools","MrChecker - devonfw testing tool","Test Framework Modules"],"text":"Web API Module\n\n\nService Virtualization\n\n\n\nWhat is service virtualization\n\n\nHow to plug in service virtualization into Application Under Test\n\n\nHow to make a virtual asset\n\n\nSmoke Tests virtualization\n\n\n\n\n\nIs it doable to keep pace in QA with today’s software agile approach?\n\nDevOps + Microservices + Shift left + Time to Market == ? Service virtualization ?\n\n\n\n\n\n\n\nTest pyramid\n\n\n\n\n\n\n\nWhat is service virtualization\n\nService Virtualization has become recognized as one of the best ways to speed up testing and accelerate your time to market.\n\n\nService virtualization lets you automatically execute tests even when the application under test’s dependent system components (APIs, third-party applications, etc.) cannot be properly accessed or configured for testing. By simulating these dependencies, you can ensure that your tests will encounter the appropriate dependency behaviour and data each and every time that they execute.\n\n\nService virtualization is the simulation of interfaces – not the virtualization of systems.\n\n\nAccording to Wikipedia’s service virtualization entry: Service virtualization emulates the behaviour of software components to remove dependency constraints on development and testing teams. Such constraints occur in complex, interdependent environments when a component connected to the application under test is:\n\n\n\n\nNot yet completed\n\n\nStill evolving\n\n\nControlled by a third-party or partner\n\n\nAvailable for testing only in a limited capacity or at inconvenient times\n\n\nDifficult to provision or configure in a test environment\n\n\nNeeded for simultaneous access by different teams with varied test data setup and other requirements\n\n\nRestricted or costly to use for load and performance testing\n\n\n\n\nFor instance, instead of virtualizing an entire database (and performing all associated test data management as well as setting up the database for every test session), you monitor how the application interacts with the database, then you emulate the related database behaviour (the SQL queries that are passed to the database, the corresponding result sets that are returned, and so forth).\n\n\n\nMocks, stubs and virtual services\n\nThe most commonly discussed categories of test doubles are mocks, stubs and virtual services.\n\n\nStub: a minimal implementation of an interface that normally returns hardcoded data that is tightly coupled to the test suite. It is most useful when the suite of tests is simple and keeping the hardcoded data in the stub is not an issue. Some stubs are handwritten; some can be generated by tools. A stub is normally written by a developer for personal use. It can be shared with testers, but wider sharing is typically limited by interoperability issues related to software platform and deployment infrastructure dependencies that were hardcoded. A common practice is when a stub works in-process directly with classes, methods, and functions for the unit, module, and acceptance testing. Some developers will say that a stub can also be primed, but you cannot verify an invocation on a stub. Stubs can also be communicating \"over the wire\", for example, HTTP, but some would argue that they should be called virtual services in that case.\n\n\nMock: a programmable interface observer, that verifies outputs against expectations defined by the test. It is frequently created using a third party library, for example in Java that is Mockito, JMock or WireMock. It is most useful when you have a large suite of tests and a stub will not be sufficient because each test needs a different data set up and maintaining them in a stub would be costly. The mock lets us keep the data set-up in the test. A mock is normally written by a developer for personal use but it can be shared with testers. However, wider sharing is typically limited by interoperability issues related to software platform and deployment infrastructure dependencies that were hardcoded. They are most often work-in-progress directly with classes, methods, and functions for a unit, module, and acceptance testing. Mock provides responses based on a given request satisfying predefined criteria (also called request or parameter matching). A mock also focuses on interactions rather than state so mocks are usually stateful. For example, you can verify how many times a given method was called or the order of calls made to a given object.\n\n\nVirtual service: a test double often provided as a Software-as-a-Service (SaaS), is always called remotely, and is never working in-process directly with methods or functions. A virtual service is often created by recording traffic using one of the service virtualization platforms instead of building the interaction pattern from scratch based on interface or API documentation. A virtual service can be used to establish a common ground for teams to communicate and facilitate artefact sharing with other development teams as well as testing teams. A virtual service is called remotely (over HTTP, TCP, etc.) normally supports multiple protocols (e.g. HTTP, MQ, TCP, etc.), while a stub or mock normally supports only one. Sometimes virtual services will require users to authorize, especially when deployed in environments with enterprise-wide visibility. Service virtualization tools used to create virtual services will most often have user interfaces that allow less tech-savvy software testers to hit the ground running, before diving into the details of how specific protocols work. They are sometimes backed by a database. They can also simulate non-functional characteristics of systems such as response times or slow connections. You can sometimes find virtual services that provide a set of stubbed responses for given request criteria and pass every other request to a live backend system (partial stubbing). Similar to mocks, virtual services can have quite complex request matchers, that allow having one response returned for many different types of requests. Sometimes, virtual services simulate system behaviours by constructing parts of the response based on request attributes and data.\n\n\nIt is often difficult to say definitely which of the following categories a test double fits into. They should be treated as a spectrum rather than strict definitions.\n\n\n\n\nPlug in service virtualization\n\nClassic application structure\n\n\n\n\n\n\nThis is a quite common application structure, where we have any of the following in Application Under Test (AUT):\n\n\n\n\nUI / GUI\n\n\nWebAPI\n\n\n3rd party service\n\n\n\n\n\nClassic application structure with virtualization\n\n\n\n\n\n\nThis classic application is quite fragile for development and/or test process. Especially so, if the component (WebAPI) connected to the Application Under Test is:\n\n\n\n\nNot yet completed\n\n\nStill evolving\n\n\nControlled by a third-party or partner\n\n\nAvailable for testing only in limited capacity or at inconvenient times\n\n\nDifficult to provision or configure in a test environment\n\n\nNeeded for simultaneous access by different teams with varied test data setup and other requirements\n\n\nRestricted or costly to use for load and performance testing\n\n\n\n\nYou can find the full list of such \"classic application structure\" limitations here What-is-service-virtualization.\n\n\n*Service virtualization is the key solution to address such a list of impediments. *\n\n\nFor simplicity, AUT connects to other components by TCP/IP protocol. Therefore AUT has an IP address and port number where given components operate. To plug in virtualization server, the author of AUT ought to switch IP and port to \"proxy server\" instead of real endpoint component (WebAPI) . Finally, \"proxy server\" maps requests come from AUT with either virtual assets or real endpoint component (WebAPI). How do maps work in such a \"proxy server\"? Have a look here How-to-make-virtual-asset\n\n\nTherefore AUT is build either with:\n\n\n\n\nswitchable property file acquired on startup\n\n\n\n\nor\n\n\n\n\n\"on the fly\" operation to change IP and ports of connected components.\n\n\n\n\n\nClassic APP structure with full scope - Binding in service virtualization\n\n\n\n\n\n\n\n\nHow to make a virtual asset\n\nThis can be done in four ways:\n\n\n\n\nRecord all traffic (Mappings and Responses) that comes through proxy - by UI\n\n\nRecord all traffic (Mappings and Responses) that comes through proxy - by Code\n\n\nCreate Mappings and Responses manually by text files\n\n\nCreate Mappings and Responses manually by code\n\n\n\n\nRecord all traffic (Mappings and Responses) that comes through proxy - UI\n\nFull article here Wiremock record-playback.\n\n\nFirst, start an instance of WireMock running standalone. Once that’s running, visit the recorder UI page at http://localhost:8080/__admin/recorder (assuming you started WireMock on the default port of 8080).\n\n\n\n\n\n\n\nEnter the URL you wish to record from in the target URL field and click the Record button. You can use http://example.mocklab.io to try it out.\n\n\nNow you need to make a request through WireMock to the target API so that it can be recorded. If you’re using the example URL, you can generate a request using curl:\n\n\n\n\n\n\n\nNow click stop. You should see a message indicating that one stub was captured.\n\n\nYou should also see that a file has been created called something like recordables_123-40a93c4a-d378-4e07-8321-6158d5dbcb29.json under the mappings directory created when WireMock started up, and that a new mapping has appeared at http://localhost:8080/__admin/mappings.\n\n\nRequesting the same URL again (possibly disabling your wifi first if you want a firm proof) will now serve the recorded result:\n\n\n\n\n\n\n\n\nRecord all traffic (Mappings and Responses) that comes through proxy - by Code\n\nAn example of how such a record can be achieved\n\n\n\n\n\n\n\n\nCreate Mappings and Responses manually by text files\n\nEMPTY\n\n\n\nCreate Mappings and Responses manually by code\n\nLink to full file structure: REST_FarenheitToCelsiusMethod_Test.java\n\n\nStart up Virtual Server\n\n\n\n\n\n\n\nPlug in a virtual asset\n\nREST_FarenheitToCelsiusMethod_Test.java\n\n\n\n\n\n\n\nLink to full file structure: StubREST_Builder.java\n\n\nSource link to How to create Stub.\n\n\nStubREST_Builder.java\n\n\n\n\n\n\n\n\n\n\nStart a virtual server\n\nThe following picture presents the process of executing Smoke Tests in a virtualized environment:\n\n\n\n\n\n\n\nInstall docker service\n\nIf docker is not already installed on machine (this should be checked during C2C creation), install docker, docker-compose, apache2-utils, openssl (You can use script to install docker &amp; docker-compose OR refer to this post and add Alias for this machine &lt;C2C_Alias_Name&gt;):\n\n\n\n\nrun the script\n\n\nsudo apt-get install -y apache2-utils\n\n\n\n\n\nBuild a docker image\n\nDockerfile:\n\n\n\n\n\n\n\nExecute the following steps with a specified version to build a docker image and push it to the repository :\n\n\n\n\n\n\n\n\nRun docker image\n\nTo run a docker image, execute the following command:\n\n\n\n\n\n\n\nWhere:\n\n\n-p - publish a container’s port to the host\n\n\n-v - bind mount a volume. WireMock server creates two directories under the current one: mappings and __files. It is necessary to mount directories with already created mappings and responses to make it work.\n\n\n-restart always - restart policy to apply when a container exists\n\n\nAll of the parameters are described in: official docker documentation\n\n\n\n\nMap requests with virtual assets\n\nWhat is WireMock?\n\n\nWireMock is an HTTP mock server. At its core it is a web server that can be primed to serve canned responses to particular requests (stubing) and that captures incoming requests so that they can be checked later (verification). It also has an assortment of other useful features including record/playback of interactions with other APIs, injection of faults and delays, simulation of stateful behaviour.\n\n\nFull documentation can be found under the following link: WireMock\n\n\nRecord / create virtual assets mappings\n\nRecord\n\n\nWireMock can create stub mappings from requests it has received. Combined with its proxying feature, this allows you to \"record\" stub mappings from interaction with existing APIs.\n\n\nRecord and playback (Legacy): documentation\n\n\n\n\n\n\n\nOnce it’s started and request is sent to it, it will be redirected to \"http://search.twitter.com\" and traffic (response) is saved to files in mappings and __files directories for further use.\n\n\nRecord and playback (New): documentation\n\n\n\nEnable mappings in a virtual server\n\nWhen the WireMock server starts, it creates two directories under the current one: mappings and __files. To create a stub, it is necessary to drop a file with a .json extension under mappings.\n\n\nRun docker with mounted volumes\n\n\nMappings are in a repository. It is necessary to mount directories with already created mappings and responses to make it work:\n\n\n\n\n\n\n\nThe description of how to build and run docker is available under: Docker run command description\n\n\nRecorded mappings\n\n\nRecorded mappings are kept in the project repository.\n\n\n\nCreate a user and map them to docker user\n\nTo enable the connection from Jenkins to Virtual Server (C2C), it is necessary to create a user and map them to docker group user. It can be done using the following command:\n\n\n\n\n\n\n\nTo set the password for a wiremock user:\n\n\n\n\n\n\n\n\nCreate SSH private and public keys for a wiremock user\n\nSSH keys serve as a means of identifying yourself to an SSH server using public-key cryptography and challenge-response authentication. One immediate advantage this method has over traditional password is that you can be authenticated by the server without ever having to send your password over the network.\n\n\nTo create an SSH key, log in as wiremock (previously created user).\n\n\n\n\n\n\n\nThe .ssh directory is not by default created below user home directory. Therefore, it is necessary to create it:\n\n\n\n\n\n\n\nNow we can proceed with creating an RSA key using ssh-keygen (a tool for creating new authentication key pairs for SSH):\n\n\n\n\n\n\n\nA key should be created under /.ssh/id_rsa\nAppending the public keys to authorized_keys:\n\n\n\n\n\n\n\n\nInstall an SSH key in Jenkins\n\nTo add an SSH key to Jenkins, go to credentials in your job location. Choose the folder within credentials, then 'global credentials', 'Add credentials'. Fill in the fields. Finally, the entry should be created.\n\n\n\nBuild a Jenkins Groovy script\n\nThe description of how to use SSH Agent plugin in Jenkins pipeline can be found under: https://www.karthikeyan.tech/2017/09/ssh-agent-blue-ocean-via-jenkins.html\n\n\nExample of use:\n\n\n\n\n\n\n\nWhere: env.WIREMOCK_CREDENTIALS is a credential id of previously created wiremock credentials. Now that it is present, we can execute commands on a remote machine, where in ssh command:\nenv.WIREMOCK_USERNAME - user name of user connected with configured private key\nenv.WIREMOCK_IP_ADDRESS - ip address of the machine where this user with this private key exists\n\n\n\nPull repository with virtual assets\n\nTo pull the repository on a remote machine, it is necessary to use the previously described SSH Agent plugin. An example of use:\n\n\n\n\n\n\n\nWhere:\n\n\nwithCredentials allows various kinds of credentials (secrets) to be used in idiosyncratic ways. Each binding will define an environment variable active within the scope of the step. Then the necessary commands are executed:\n\n\ncd …​ - command will change from current directory to the specified directory with git repository\n\n\ngit fetch …​ ;git reset …​ ;git clean …​ - pull from GIT branch. Git pull or checkout are not used here to prevent the situation with wrong coding between Mac OSX/Linux etc.\n\n\nPLEASE remember that when using this script for the first time, the code from previous block should be changed to:\n\n\n\n\n\n\n\n\n\nInstall an application with Smoke environment\n\nUpdate properties settings file\n\nNew settings file is pushed to the repository. Example configuration:\n\n\n\n\n\n\n\nAddress of service (backend) should be changed to wiremock address as it is shown on listing to change the default route.\n\n\n\nBuild an application with updated properties file\n\nNew versions of application are prepared by Jenkins job.\n\n\n\nInstall an application on target properties file\n\nInstallation of an application is actually executed in a non-automated way using SeeTest environment.\n\n\n\n\nUI tests\n\nRun Jenkins job\n\nJenkinsfile:\n\n\n\n\n\n\n\nstageStartVirtualServer.groovy:\n\n\n\n\n\n\n\nstageMapApiRequests.groovy:\n\n\n\n\n\n\n\nstageInstallApplication.groovy:\n\n\n\n\n\n\n\nstageUITests.groovy:\n\n\n\n\n\n\n\nConfiguration\n\n\nIt is possible to configure Jenkins job in two ways. First one is to edit the Jenkinsfile. All of the properties are in properties collection as below:\n\n\n\n\n\n\n\nSecond way is to add properties in 'Configure job'. All of the properties there are overriding properties from Jenkinsfile (the have the highest priority). They can then be set durring 'Build with Paremeters' process.\n\n\nReports\n\n\nAfter a job execution 'Allure report' and 'Cucumber-JVM' reports should be visible. If any tests fail, You can check on which screen (printscreen from failures is attached, why and etc.)\n\n\n\n\n\n"}