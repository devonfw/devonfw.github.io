{"type":"doc","filename":"architecture_guide.asciidoc.html","anchor":"architecture_guide.asciidoc_layer-specification","title":"Layer specification","breadcrumbs":[".net","Architecture basics","Introduction"],"text":"Layer specification\n\n\n\nIt is important to understand the distinction between layers and tiers. Layers describe the logical groupings of the functionality and components in an application; whereas tiers describe the physical distribution of the functionality and components on separate servers, computers, networks, or remote locations. Although both layers and tiers use the same set of names (presentation, business, services, and data), remember that only tiers imply a physical separation. It is quite common to locate more than one layer on the same physical machine (the same tier). You can think of the term tier as referring to physical distribution patterns such as two-tier, three-tier, and n-tier.\n\n\n\n— Layered Application Guidelines\nMSDN Microsoft\n\n\n\nThe proposed architecture makes use of cooperating components called layers. To develop specific functionality each layer contains a set of components which is capable to develop such functionalities.\n\n\nThe next figure represents the different layers:\n\n\n\n\n\nFigure 72. High level architecture representation\n\n\nThe layers are separated in physical tiers making use of interfaces. This pattern makes possible to be flexible in different kind of projects maximizing performance and deployment strategies (synchronous/asynchronous access, security, component deployment in different environments, microservices…​). Another important point is to provide automated unit testing or test-driven development (TDD) facilities.\n\n\nApplication layer\n\nThe Application Layer encapsulates the different .Net projects and its resource dependencies and manages the user interaction depending on the project’s nature.\n\n\n\n\n\nFigure 73. Net application stack\n\n\nThe provided application template implements an dotnet API application. Also integrates by default the Swagger client. This provides the possibility to share the contract with external applications (angular, mobile apps, external services…​).\n\n\n\nBusiness layer\n\nThe business layer implements the core functionality of the application and encapsulates the component’s logic.\nThis layer provides the interface between the data transformation and the application exposition. This allow the data to be optimized and ready for different data consumers.\n\n\nThis layer may implement for each main entity the API controller, the entity related service and other classes to support the application logic.\n\n\nIn order to implement the service logic, the services class must follow the next specification:\n\n\n\n\n\n\n\nPE: devon4Net API template shows how to implement the TODOs service as follows:\n\n\n\n\n\n\n\nWhere Service is the base service class to be inherited and have full access for the Unit of work, TodoContext is the TODOs database context and ITodoService is the interface of the service, which exposes the public extended methods to be implemented.\n\n\n\nData layer\n\nThe data layer orchestrates the data obtained between the Domain Layer and the Business Layer. Also transforms the data to be used more efficiently between layers.\n\n\nSo, if a service needs the help of another service or repository, the implemented Dependency Injection is the solution to accomplish the task.\n\n\nThe main aim of this layer is to implement the repository for each entity. The repository’s interface is defined in the Domain layer.\n\n\nIn order to implement the repository logic, the repository class must follow the next specification:\n\n\n\n\n\n\n\nPE: devon4Net API template shows how to implement the TODOs repository as follows:\n\n\n\n\n\n\n\nWhere Repository is the the base repository class to be inherited and have full access for the basic CRUD operations, Todos is the entity defined in the database context. ITodoRepository is the interface of the repository, which exposes the public extended methods to be implemented.\n\n\n\n\n\n\n\n\nPlease remember that &lt;T&gt; is the mapped class which reference the entity from the database context. This abstraction allows to write services implementation with different database contexts\n\n\n\n\n\n\nDomain layer\n\nThe domain layer provides access to data directly exposed from other systems. The main source is used to be a data base system. The provided template makes use of Entity Framework solution from Microsoft in order to achieve this functionality.\n\n\nTo make a good use of this technology, Repository Pattern has been implemented with the help of Unit Of Work pattern. Also, the use of generic types are makes this solution to be the most flexible.\n\n\nRegarding to data base source, each entity is mapped as a class. Repository pattern allows to use this mapped classes to access the data base via Entity framework:\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhere &lt;T&gt; is the mapped class which reference the entity from the database.\n\n\n\n\n\nThe repository and unit of work patterns are create an abstraction layer between the data access layer and the business logic layer of an application.\n\n\n\n\n\n\n\n\nDomain Layer has no dependencies with other layers. It contains the Entities, datasources and the Repository Interfaces.\n\n\n\n\n\n\ndevon4Net architecture layer implementation\n\nThe next picture shows how the devon4Net API template implements the architecture described in previous points:\n\n\n\n\n\nFigure 74. devon4Net architecture implementations\n\n\nCross-Cutting concerns\n\nCross-cutting provides the implementation functionality that spans layers. Each functionality is implemented through components able to work stand alone. This approach provides better reusability and maintainability.\n\n\nA common component set of cross cutting components include different types of functionality regarding to authentication, authorization, security, caching, configuration, logging, and communication.\n\n\n\n\n\n"}