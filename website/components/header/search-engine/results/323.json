{"type":"doc","filename":"devonfw-guide_devon4net.wiki_templates.asciidoc.html","anchor":"devonfw-guide_devon4net.wiki_templates.asciidoc_webapi-template","title":"WebAPI Template","breadcrumbs":[".net","Templates","Templates"],"text":"WebAPI Template\n\nThis section contains all of the information about the template that corresponds to the Devon4net WebAPI. This template will allow you to easily create a functional API with everything set up so you can start coding for your specific domain.\n\n\nFirstly, all the details about the contents of the package will be explained. Going through all of the directory tree explaining the most imporant concepts. Then we will show an example of how to add the entity Student from the domain layer all the way to the controller, so you can understand how the architecture works on this template and how the layers interact with each other.\n\n\nDevon4Net.Application.WebAPI\n\nThis is the startup project of the template. Its main purpose is to launch the api and configure it using the settings files. The following figure shows the directory tree you will find when you first use the template.\n\n\n\n\n\nFigure 145. Devon4Net.Application.WebAPI Directory tree\n\n\nEverything will be set up in the Program.cs file as for any .Net 6 Core API project. Going through this file, you will find all the configuration included with the template, such as middlewares and Dependency Injection.\n\n\nappsettings.json\n\n\n\n\n\n\nIn the following list all the configuration fields are described:\n\n\n\n\nUseIIS: Boolean that indicates if IIS is used.\n\n\nValidateIssuerSigningKey: Boolean that controls if validation of the security key that signed the securityToken is called.\n\n\nUseXsrf: Boolean that adds Anti Forgery middleware to prevent XSRF attacks.\n\n\nUseModelStateValidation: Boolean that indicates if model validation is called.\n\n\nEnvironment: Running environment to load the corresponding configuration (Development, Production…​)\n\n\nForceUseHttpsRedirection: Boolean to force adding a middleware that redirects HTTP requests to HTTPS.\n\n\nKestrel: Kestrel server configuration\n\n\n\nUseHttps: Boolean to indicate if the connection needs to be secured via HTTPS.\n\n\nHttpProtocol: Hypertext protocol used.\n\n\n\n\n\n\n\nProtocol\nDescription\n\n\nHttp1\nHTTP/1.x (default)\n\n\nHttp2\nHTTP/2\n\n\nHttp1andHttp2\nBoth HTTP/1.x and HTTP/2\n\n\nnone\n\n\n\n\n\n\nApplicationPort: Port number where the API will listen\n\n\nSslProtocol: SSL encrytion protocol for Https\n\n\n\n\n\n\n\nProtocol\nDescription\n\n\nTls12\nTLS 1.2 (default, needed for Https2)\n\n\nTls13\nTLS 1.3\n\n\nnone\n\n\n\n\n\n\nExtraSettings: Some extra settings for Kestrel\n\n\n\nKeepAliveTimeout: Sets the keep-alive timeout in seconds.\n\n\nMaxConcurrentConnections: Maximum number of open connections. Null is unlimited. Default is 100.\n\n\nMaxConcurrentUpgradedConnections: Maximum number of open upgraded connectinos. Null is unlimited. An upgraded connection is one that has been switched from HTTP to another protocol. Default is 100.\n\n\nMaxRequestBodySize: Maximum allowed size of any request body in MB. Default is 28.6MB.\n\n\nHttp2MaxStreamsPerConnection: Maximum number of concurrent request streams per HTTP/2 connection. Excess streams will be refused. Default is 100.\n\n\nHttp2InitialConnectionWindowSize: Indicates how much request body data the server is willing to receive and buffer at a time aggregated across all requests (streams) per connection. Value must be greater or equal to 65,535 and less than 2^31. Defaults to 128 KB.\n\n\nHttp2InitialStreamWindowSize: Indicates how much request body data the server is willing to receive and buffer at a time per stream.\n\n\nAllowSynchronousIO: Boolean that controls wether Synchronous IO operations are allowed in requests.\n\n\n\n\n\n\n\n\nIIS: Internet Information Services configuration\n\n\n\nForwardClientCertificate:  Populates the ITLSConnectionFeature if the MS-ASPNETCORE-CLIENTCERT request header is present\n\n\nAutomaticAuthentication: If true the middleware should set HttpContext.User. If false the middleware will only provide an identity when explicitly requested by the AuthenticationScheme. Note Windows Authentication must also be enabled in IIS for this to work.\n\n\nAuthenticationDisplayName: Sets the display name shown to users on login pages. The default is null\n\n\n\n\n\n\n\nFor each environment you can have a different configuration if you wish. You will find an appsettings.Development.json file where the configuration for the different components used in the template is placed. Please go through the documentation of each component to learn more about how are they configured.\n\n\n\n\nDevon4Net.Application.Implementation\n\nThis is where all the magic happens. This project holds all the classes needed to implement the API end-points. The following image shows the structure you will find in this project.\n\n\n\n\n\nFigure 146. Devon4Net.Application.WebAPI.Implementation Directory tree\n\n\n\n\n\n\n\n\nPlease refer to documentation about Architecture to understand better the proposed architecture which is Onion Architecture.\n\n\n\n\n\nConfiguration\n\nIn this directory the Configuration is placed, you will find all the dependency injection code for this project in the static class DevonConfiguration. The code is divided into many private extensions based on their intended use, all of which are called by one main public extension for the IServiceCollection interface in the Program.cs file.\n\n\n\n\n\n\n\n\nIf you need to segregate chunks of code, don’t be afraid to add extra static classes. This will improve reading and it will make it much easier to locate items later.\n\n\n\n\n\n\nDomain\n\nAs you may have learned thanks to the architecture document, this is the core of the application. It holds the entities and the contracts for the operations you can execute on them, that last being the repository interfaces.\n\n\nYou will be able to find also the different database contexts for the application in the Database directory. These contexts will allow EntityFramework to work properly by extending DbContext class.\n\n\n\n\n\nFigure 147. Devon4Net.Application.WebAPI.Implementation Domain layer\n\n\nThe repositories interfaces extend from a generic repository interface IRepository&lt;T&gt; available in Devon4Net. As you can see in figure 3, Devon4Net already comes with some examples of implementation for some entities. Please revise them so that you have a better understanding of how they work.\n\n\n\nData\n\nThe Data directory corresponds to the Data Layer and implements all the interfaces contracts. This Repositories extend from a generic repository implementation Repository&lt;T&gt; available in Devon4Net. As you can see in the next figure, the template also come with some examples of implementation.\n\n\n\n\n\nFigure 148. Devon4Net.Application.WebAPI.Implementation Data layer\n\n\n\nBusiness\n\nThe Business directory is where all the application logic is placed, it corresponds to the Business Layer. You will find a lot of implemented examples as shown in the next image.\n\n\n\n\n\nFigure 149. Devon4Net.Application.WebAPI.Implementation Business layer\n\n\nThese are:\n\n\n\n\nAntiForgeryTokenManagement: This is an example of how to use the XSRF protection in API controllers. It contains a controller class with a working example.\n\n\n\n\nFigure 150. AntiForgeryTokenManagement directory\n\n\n\nAuthManagement: This example shows how to use Authorization in API controllers thanks to Json Web Tokens. It contains a controller class and some response entities needed to return information.\n\n\n\n\nFigure 151. AuthManagement directory\n\n\n\nEmployeeManagement: This directory contains all the implementation classes for entity type Employee.\n\n\n\n\nFigure 152. EmployeeManagement directory\n\n\n\nMediatRManagement: Example of how implement MediatR for using CQRS pattern.\n\n\n\n\nFigure 153. MediatRManagement directory\n\n\n\nRabbitMqManagement: Sample of implementation of RabbitMq queues.\n\n\n\n\nFigure 154. RabbitMqManagement directory\n\n\n\nTodoManagement: Implementation sample of entity type Todo.\n\n\n\n\nFigure 155. TodoManagement directory\n\n\n\n\n\n\n\nSample of use\n\n\n\n\n\n\n\nIf you don’t know how to install and use this template, please refer to documentation on how to do it.\n\n\n\n\n\nIn this part we will be creating CRUD (Create, Read, Update and Delete) operations for the entity type Student. Before that, we will delete the samples that come with the template.\n\n\nStep 1: Entity\n\nFirst we will need the object Student. For that we will need to create a new Student.cs class in Domain\\Entities:\n\n\n\n\n\n\n\nOur student should have an Identifier, and we will also put some interesting properties, name and surname for example.\n\n\n\n\n\n\n\n\nIs good practice to override object methods: Equals(object o), GetHashCode() and ToString().\n\n\n\n\n\n\nStep 2: Context\n\nEntityFramework will need a context to be able to work with Students. Lets create a StudentContext.cs class in Domain\\Database:\n\n\n\n\n\n\n\n\nStep 3: Repository contract\n\nThe repository contract in Data\\RepositoryInterfaces will allow us to inject the repository and will increase decoupling. It will be implemented in the next step. You can inherit methods from Devon4Net IRepository as shown, but we will be also implementing a couple of queries:\n\n\n\n\n\n\n\nEverything should be asynchronous making use of the Task class.\n\n\n\nStep 4: Repository implementation\n\nNow we will need a repository implementation for the previous interface. It will be placed in Data\\Repositories, it will inherit also from Devon4Net generic repository and will implement interface methods:\n\n\n\n\n\n\n\n\nStep 5: StudentDto\n\nTo increase decoupling, we will create a copy of the entity Student in Business\\Dto for the Business layer. To make it a little different we will be including the surname in the property FullName and it will be separated before being stored in the database and viceversa:\n\n\n\n\n\n\n\nWe will need also a converter placed in Business\\Converters so we can transform it in both directions:\n\n\n\n\n\n\n\n\nStep 6: Service\n\nNow we will need a service in Business\\StudentManagement\\Service. The service will execute all the necessary operations.  In this case as it is a simple CRUD it will only call the repository. The Devon4Net Service class implements Unit of Work pattern.\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 7: Controller\n\nThe controller will end up looking like this and needs to be placed in Business\\StudentManagement\\Controllers. It uses the IStudentService via dependency injection.\n\n\n\n\n\n\n\n\nStep 8: Dependency Injection\n\nNow we are ready to inject the context in Configuration\\DevonConfiguration.cs. In this example we are creating a database stored in memory:\n\n\n\n\n\n\n\nAlso the repository and the service, so we can use them in the entire solution.\n\n\n\n\n\n\n\n\nTest\n\nNow you can run the application and go to the path swagger/index.html.\n\n\n\n\n\n\n\n\ntake a look at your application port and the protocol you configured (http or https).\n\n\n\n\n\n\n\n\nFigure 156. Swagger test for Student\n\n\n\n\n\n"}