{"type":"doc","filename":"devonfw-guide_devon4net.wiki_packages.asciidoc.html","anchor":"devonfw-guide_devon4net.wiki_packages.asciidoc_devon4net.infrastructure.unitofwork","title":"Devon4Net.Infrastructure.UnitOfWork","breadcrumbs":[".net","Packages","Packages"],"text":"Devon4Net.Infrastructure.UnitOfWork\n\nThe idea of Unit of Work is related to the successful implementation of the Repository Pattern. It is necessary to first comprehend the Repository Pattern in order to fully understand this concept.\n\n\nThe Repository Pattern\n\nA repository is a class defined for an entity, that contains all of the operations that may be executed on that entity. For example, a repository for an entity Employee will contain basic CRUD operations as well as any additional potential actions connected to it. The following procedures can be used to implement the Repository Pattern:\n\n\n\n\nOne repository per entity (non-generic) : This approach makes use of a single repository class for each entity. For instance, if you have two entities, Todo and Employee, each will have its own repository.\n\n\nGeneric repository: A generic repository is one that can be used for all entities.\n\n\n\n\nUnit of Work in the Repository Pattern\n\nUnit of Work is referred to as a single transaction that involves multiple operations of insert/update/delete. It means that, for a specific user action, all transactions are performed in a single transaction rather than several database transactions.\n\n\n\n\n\nFigure 116. Unit of work diagram\n\n\n\n\nConfiguration\n\nConnection strings must be added to the configuration in the file appsettings.environment.json as follows:\n\n\n\n\n\n\n\n\nSetting up in Devon\n\nFor setting it up using the Devon4NetApi template just configure the connection strings in the appsettings.Development.json file.\n\n\nTo add Databases, use the SetupDatabase method in the DevonConfiguration.cs file:\n\n\n\n\n\n\n\nYou must provide the configuration, the connection string key, and the database type.\n\n\nThe supported databases are:\n\n\n\n\nSqlServer\n\n\nSqlite\n\n\nInMemory\n\n\nCosmos\n\n\nPostgreSQL\n\n\nMySql\n\n\nMariaDb\n\n\nFireBird\n\n\nOracle\n\n\nMSAccess\n\n\n\n\nSet the migrate property value to true if you need to use migrations, as shown above.\n\n\n\n\n\n\n\n\nFor more information about the use of migrations please visit the official microsoft documentation.\n\n\n\n\n\nOur typed repositories must inherit from the generic repository of the Unit Of Work component, as seen in the example below:\n\n\n\n\n\n\n\nUse the methods of the generic repository to perform your CRUD actions:\n\n\n\n\n\n\n\nThe default value for AutoSaveChanges to the Database is true, you may change it to false if you need to employ transactions.\n\n\nInject the Repository on the service of the business layer, as shown below:\n\n\n\n\n\n\n\n\nSetting up in other projects\n\nInstall the package on your solution using the Package Manager Console:\n\n\n\n\n\n\n\nCreate a Configuration static class in order to add the IRequestHandler services, for example:\n\n\n\n\n\n\n\nConfigure the component in Program.cs adding the following lines:\n\n\n\n\n\n\n\nAdd the default configuration shown in the configuration section and follow the same steps as the previous section.\n\n\n\nTips\n\nPredicate expression builder\n\n\n\n\nUse this expression builder to generate lambda expressions dynamically:\n\n\n\n\n\n\n\n\n\nWhere T is a class. At this moment, you can build your expression and apply it to obtain your results in a efficient way and not retrieving data each time you apply an expression.\n\n\n\n\nExample from My Thai Star .Net Core implementation:\n\n\n\n\n\n\n\n\n\n\n\n\n"}