{"type":"doc","filename":"services-layer.asciidoc.html","anchor":"services-layer.asciidoc_interaction-of-smart-components-through-the-services-layer","title":"Interaction of Smart Components through the services layer","breadcrumbs":["Angular","Layers","Services Layer"],"text":"Interaction of Smart Components through the services layer\n\nThe interaction of smart components is a classic problem which has to be solved in every UI technology.\nIt is basically how one dialog tells the other something has changed.\n\n\nAn example is adding an item to the shopping basket.\nWith this action there need to be multiple state updates.\n\n\n\n\nThe small logo showing how many items are currently inside the basket needs to be updated from 0 to 1\n\n\nThe price needs to be recalculated\n\n\nShipping costs need to be checked\n\n\nDiscounts need to be updated\n\n\nAds need to be updated with related products\n\n\netc.\n\n\n\n\nPattern\n\nTo handle this interaction in a scalable way we apply the following pattern.\n\n\n\n\n\nFigure 14. Smart Component interaction\n\n\nThe state of interest is encapsualted inside a store. All Smart Components interested in the state have to subscibe to the store’s API served by the public observable. Thus, with every update to the store the subscribed components receive the new value. The components basically react to state changes. Altering a store can be done directly if the desired change is synchronous. Most actions are of asynchronous nature so the UseCaseService comes into play. Its actions are void methods, which implement a use case, i.e., adding a new item to the basket. It calls asynchronous actions and can perform multiple store updates over time.\n\n\nTo put this pattern into perspective the UseCaseService is a programmatic alternative to redux-thunk or @ngrx/effects. The main motivation here is to use the full power of TypeScript’s --strictNullChecks and to let the learning curve not to become as steep as it would be when learning a new state management framework. This way actions are just void method calls.\n\n\n\nExample\n\n\n\n\nFigure 15. Smart Components interaction example\n\n\nThe example shows two Smart Components sharing the FlightSearchState by using the FlightSearchStore.\nThe use case shown is started by an event in the Smart Component FlightSearchComponent. The action loadFlight() is called. This could be submitting a search form.\nThe UseCaseService is FlightSearchService, which handles the use case Load Flights.\n\n\nUseCaseService example\n\n\n\n\n\n\n\n\nFirst the loading flag is set to true and the current flights are cleared. This leads the Smart Component showing a spinner indicating the loading action. Then the asynchronous XHR is triggert by calling the adapter. After completion the loading flag is set to false causing the loading indication no longer to be shown. If the XHR was successful, the data would be put into the store. If the XHR was not successful, this would be the place to handle a custom error. All general network issues should be handled in a dedicated class, i.e., an interceptor. So for example the basic handling of 404 errors is not done here.\n\n\n\n\n\n"}