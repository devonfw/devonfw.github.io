{"type":"doc","filename":"guide-jpa.asciidoc.html","anchor":"guide-jpa.asciidoc_entity","title":"Entity","breadcrumbs":["Java","General","Java Persistence API"],"text":"Entity\n\nEntities are part of the persistence layer and contain the actual data. They are POJOs (Plain Old Java Objects) on which the relational data of a database is mapped and vice versa. The mapping is configured via JPA annotations (javax.persistence). Usually an entity class corresponds to a table of a database and a property to a column of that table. A persistent entity instance then represents a row of the database table.\n\n\nA Simple Entity\n\nThe following listing shows a simple example:\n\n\n\n\n\n\n\nThe @Entity annotation defines that instances of this class will be entities which can be stored in the database. The @Table annotation is optional and can be used to define the name of the corresponding table in the database. If it is not specified, the simple name of the entity class is used instead.\n\n\nIn order to specify how to map the attributes to columns we annotate the corresponding getter methods (technically also private field annotation is also possible but approaches can not be mixed).\nThe @Id annotation specifies that a property should be used as primary key.\nWith the help of the @Column annotation it is possible to define the name of the column that an attribute is mapped to as well as other aspects such as nullable or unique. If no column name is specified, the name of the property is used as default.\n\n\nNote that every entity class needs a constructor with public or protected visibility that does not have any arguments. Moreover, neither the class nor its getters and setters may be final.\n\n\nEntities should be simple POJOs and not contain business logic.\n\n\n\nEntities and Datatypes\n\nStandard datatypes like Integer, BigDecimal, String, etc. are mapped automatically by JPA. Custom datatypes are mapped as serialized BLOB by default what is typically undesired.\nIn order to map atomic custom datatypes (implementations of`+SimpleDatatype`) we implement an AttributeConverter. Here is a simple example:\n\n\n\n\n\n\n\nThe annotation @Converter is detected by the JPA vendor if the annotated class is in the packages to scan. Further, autoApply = true implies that the converter is automatically used for all properties of the handled datatype. Therefore all entities with properties of that datatype will automatically be mapped properly (in our example Money is mapped as BigDecimal).\n\n\nIn case you have a composite datatype that you need to map to multiple columns the JPA does not offer a real solution. As a workaround you can use a bean instead of a real datatype and declare it as @Embeddable. If you are using Hibernate you can implement CompositeUserType. Via the @TypeDef annotation it can be registered to Hibernate. If you want to annotate the CompositeUserType implementation itself you also need another annotation (e.g. MappedSuperclass tough not technically correct) so it is found by the scan.\n\n\nEnumerations\n\nBy default JPA maps Enums via their ordinal. Therefore the database will only contain the ordinals (0, 1, 2, etc.) . So , inside the database you can not easily understand their meaning. Using @Enumerated with EnumType.STRING allows to map the enum values to their name (Enum.name()). Both approaches are fragile when it comes to code changes and refactoring (if you change the order of the enum values or rename them) after the application is deployed to production. If you want to avoid this and get a robust mapping you can define a dedicated string in each enum value for database representation that you keep untouched. Then you treat the enum just like any other custom datatype.\n\n\n\nBLOB\n\nIf binary or character large objects (BLOB/CLOB) should be used to store the value of an attribute, e.g. to store an icon, the @Lob annotation should be used as shown in the following listing:\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nUsing a byte array will cause problems if BLOBs get large because the entire BLOB is loaded into the RAM of the server and has to be processed by the garbage collector. For larger BLOBs the type Blob and streaming should be used.\n\n\n\n\n\n\n\n\n\n\n\nDate and Time\n\nTo store date and time related values, the temporal annotation can be used as shown in the listing below:\n\n\n\n\n\n\n\nUntil Java8 the java data type java.util.Date (or Jodatime) has to be used.\nTemporalType defines the granularity. In this case, a precision of nanoseconds is used. If this granularity is not wanted, TemporalType.DATE can be used instead, which only has a granularity of milliseconds.\nMixing these two granularities can cause problems when comparing one value to another. This is why we only  use TemporalType.TIMESTAMP.\n\n\n\nQueryDSL and Custom Types\n\nUsing the Aliases API of QueryDSL might result in an InvalidDataAccessApiUsageException when using custom datatypes in entity properties. This can be circumvented in two steps:\n\n\n\n\nEnsure you have the following maven dependencies in your project (core module) to support custom types via the Aliases API:\n\n\n\n\n\n\n\nMake sure, that all your custom types used in entities provide a non-argument constructor with at least visibility level protected.\n\n\n\n\n\n\nPrimary Keys\n\nWe only use simple Long values as primary keys (IDs). By default it is auto generated (@GeneratedValue(strategy=GenerationType.AUTO)). This is already provided by the class com.devonfw.&lt;projectName&gt;.general.dataaccess.api.AbstractPersistenceEntity within the classic project structure respectively com.devonfw.&lt;projectName&gt;.general.domain.model.AbstractPersistenceEntity within the modern project structure, that you can extend.\nIn case you have business oriented keys (often as String), you can define an additional property for it and declare it as unique (@Column(unique=true)).\nBe sure to include \"AUTO_INCREMENT\" in your sql table field ID to be able to persist data (or similar for other databases).\n\n\n\n\n"}