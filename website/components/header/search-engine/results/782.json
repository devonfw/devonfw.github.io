{"type":"doc","filename":"my-thai-star.wiki_master-my-thai-star.asciidoc_server-side.html","anchor":"java-design.asciidoc","title":"Java design","breadcrumbs":["<code>MyThaiStar</code>","Technical design","Server Side"],"text":"Java design\n\nIntroduction\n\nThe Java backend for My Thai Star application is going to be based on:\n\n\n\n\nDEVON4J as the Java framework\n\n\nDevonfw as the Development environment\n\n\nCobigen as code generation tool\n\n\n\n\nTo know more details about the above technologies please visit the following documentation:\n\n\n\n\nDEVON4J\n\n\nDevonfw\n\n\nCobigen\n\n\n\n\n\nBasic architecture details\n\nFollowing the DEVON4J conventions the Java My Thai Star backend is going to be developed dividing the application in Components and using a three layers architecture.\n\n\nProject modules\n\nUsing the DEVON4J approach for the Java backend project we will have a structure of a Maven project formed by three projects\n\n\n\n\n\n\n\n\n\napi: Stores all the REST interfaces and corresponding Request/Response objects.\n\n\ncore: Stores all the logic and functionality of the application.\n\n\nserver: Configures the packaging of the application.\n\n\n\n\nWe can automatically generate this project structure using the DEVON4J Maven archetype\n\n\n\nComponents\n\nThe application is going to be divided in different components to encapsulate the different domains of the application functionalities.\n\n\n\n\n\n\n\nAs main components we will find:\n\n\n\n\nBookingmanagement: Manages the bookings part of the application. With this component the users (anonymous/logged in) can create new bookings or cancel an existing booking. The users with waiter role can see all scheduled bookings.\n\n\nOrdermanagement: This component handles the process to order dishes (related to bookings). A user (as a host or as a guest) can create orders (that contain dishes) or cancel an existing one. The users with waiter role can see all ordered orders.\n\n\nDishmanagement: This component groups the logic related to the menu (dishes) view. Its main feature is to provide the client with the data of the available dishes but also can be used by other components (Ordermanagement) as a data provider in some processes.\n\n\nUsermanagement: Takes care of the User Profile management, allowing to create and update the data profiles.\n\n\n\n\nAs common components (that don’t exactly represent an application’s area but provide functionalities that can be used by the main components):\n\n\n\n\nImagemanagement: Manages the images of the application. In a first approach the Dishmanagement component and the Usermanagement component will have an image as part of its data. The Imagemanagement component will expose the functionality to store and retrieve this kind of data.\n\n\nMailservice: with this service we will provide the functionality for sending email notifications. This is a shared service between different app components such as bookingmanagement or ordercomponent.\n\n\n\n\nOther components:\n\n\n\n\nSecurity (will manage the access to the private part of the application using a jwt implementation).\n\n\nTwitter integration: planned as a Microservice will provide the twitter integration needed for some specific functionalities of the application.\n\n\n\n\n\nLayers\n\n\n\nService Layer: this layer will expose the REST api to exchange information with the client applications.\n\n\nLogic Layer: the layer in charge of hosting the business logic of the application.\n\n\nData Access Layer: the layer to communicate with the data base.\n\n\n\n\nThis architecture is going to be reflected dividing each component of the application in different packages to match those three layers.\n\n\n\nComponent structure\n\nEach one of the components defined previously are going to be structured using the three-layers architecture. In each case we will have a service package, a logic package and a dataaccess package to fit the layers definition.\n\n\n\n\n\n\n\n\nDependency injection\n\nAs it is explained in the devonfw documentation we are going to implement the dependency injection pattern basing our solution on Spring and the Java standards: java.inject (JSR330) combined with JSR250.\n\n\n\n\n\n\n\n\n\nSeparation of API and implementation: Inside each layer we will separate the elements in different packages: api and impl. The api will store the interface with the methods definition and inside the impl we will store the class that implements the interface.\n\n\n\n\n\n\n\n\n\n\n\nUsage of JSR330: The Java standard set of annotations for dependency injection (@Named, @Inject, @PostConstruct, @PreDestroy, etc.) provides us with all the needed annotations to define our beans and inject them.\n\n\n\n\n\n\n\n\n\n\nLayers communication\n\nThe connection between layers, to access to the functionalities of each one, will be solved using the dependency injection and the JSR330 annotations.\n\n\n\n\n\n\n\nConnection Service - Logic\n\n\n\n\n\n\n\nConnection Logic - Data Access\n\n\n\n\n\n\n\n\n\nService layer\n\nThe services layer will be solved using REST services with the JAX-RS implementation.\n\n\nTo give service to the defined User Stories we will need to implement the following services:\n\n\n\n\nprovide all available dishes.\n\n\nsave a booking.\n\n\nsave an order.\n\n\nprovide a list of bookings (only for waiters) and allow filtering.\n\n\nprovide a list of orders (only for waiters) and allow filtering.\n\n\nlogin service (see the Security section).\n\n\nprovide the current user data (see the Security section)\n\n\n\n\nFollowing the naming conventions proposed for Devon4j applications we will define the following end points for the listed services.\n\n\n\n\n(POST) /mythaistar/services/rest/dishmanagement/v1/dish/search.\n\n\n(POST) /mythaistar/services/rest/bookingmanagement/v1/booking.\n\n\n(POST) /mythaistar/services/rest/ordermanagement/v1/order.\n\n\n(POST) /mythaistar/services/rest/bookingmanagement/v1/booking/search.\n\n\n(POST) /mythaistar/services/rest/ordermanagement/v1/order/search.\n\n\n(POST) /mythaistar/services/rest/ordermanagement/v1/order/filter (to filter with fields that does not belong to the Order entity).\n\n\n(POST) /mythaistar/login.\n\n\n(GET) /mythaistar/services/rest/security/v1/currentuser/.\n\n\n\n\nYou can find all the details for the services implementation in the Swagger definition included in the My Thai Star project on Github.\n\n\nService api\n\nThe api.rest package in the service layer of a component will store the definition of the service by a  Java interface. In this definition of the service we will set-up the endpoints of the service, the type of data expected and returned, the HTTP method for each endpoint of the service and other configurations if needed.\n\n\n\n\n\n\n\n\nService impl\n\nOnce the service api is defined we need to implement it using the Java interface as reference. We will add the service implementation class to the impl.rest package and implement the RestService interface.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou can see the Devon4j conventions for REST services here. And the My Thai Star services definition here as part of the My Thai Star project.\n\n\n\n\n\n\n\n\nLogic layer\n\nIn the logic layer we will locate all the business logic of the application. We will keep the same schema as we have done for the service layer, having an api package with the definition of the methods and a impl package for the implementation.\n\n\nAlso, inside the api package, a to package will be the place to store the transfer objects needed to pass data through the layers of the component.\n\n\n\n\n\n\n\nThe logic api definition:\n\n\n\n\n\n\n\nThe logic impl class:\n\n\n\n\n\n\n\nThe BeanMapper will provide the needed transformations between entity and transfer objects.\n\n\nAlso, the logic layer is the place to add validation for Authorization based on roles as we will see later.\n\n\n\nData Access layer\n\nThe data-access layer is responsible for managing the connections to access and process data. The mapping between java objects to a relational database is done in Devon4j with the spring-data-jpa.\n\n\nAs in the previous layers, the data-access layer will have both api and impl packages. However, in this case, the implementation will be slightly different. The api package will store the component main entities and, inside the _api package, another api.repo package will store the Repositories. The repository interface will extend DefaultRepository interface (located in com.devonfw.module.jpa.dataaccess.api.data package of devon4j-starter-spring-data-jpa ).\n\n\nFor queries we will differentiate between static queries (that will be located in a mapped file) and dynamic queries (implemented with QueryDsl). You can find all the details about how to manage queries with Devon4j here.\n\n\nThe default data base included in the project will be the H2 instance included with the Devon4j projects.\n\n\nTo get more details about pagination, data base security, _concurrency control, inheritance or how to solve the different relationships between entities visit the official devon4j dataaccess documentation.\n\n\n\nSecurity with Json Web Token\n\nFor the Authentication and Authorization the app will implement the json web token protocol.\n\n\nJwt basics\n\n\n\nA user will provide a username / password combination to our auth server.\n\n\nThe auth server will try to identify the user and, if the credentials match, will issue a token.\n\n\nThe user will send the token as the Authorization header to access resources on server protected by JWT Authentication.\n\n\n\n\n\n\n\n\n\n\nJwt implementation details\n\nThe Json Web Token pattern will be implemented based on the Spring Security framework that is provided by default in the Devon4j projects.\n\n\nAuthentication\n\nBased on the Spring Security approach, we will implement a class extending WebSecurityConfigurerAdapter (Devon4j already provides the BaseWebSecurityConfig class) to define the security entry point and filters. Also, as My Thai Star is a mainly public application, we will define here the resources that won’t be secured.\n\n\nList of unsecured resources:\n\n\n\n\n/services/rest/dishmanagement/**: to allow anonymous users to see the dishes info in the menu section.\n\n\n/services/rest/ordermanagement/v1/order: to allow anonymous users to save an order. They will need a booking token but they won’t be authenticated to do this task.\n\n\n/services/rest/bookingmanagement/v1/booking: to allow anonymous users to create a booking. Only a booking token is necessary to accomplish this task.\n\n\n/services/rest/bookingmanagement/v1/booking/cancel/**: to allow cancelling a booking from an email. Only the booking token is needed.\n\n\n/services/rest/bookingmanagement/v1/invitedguest/accept/**: to allow guests to accept an invite. Only a guest token is needed.\n\n\n/services/rest/bookingmanagement/v1/invitedguest/decline/**: to allow guests to reject an invite. Only a guest token is needed.\n\n\n\n\nTo configure the login we will set up the HttpSecurity object in the configure method of the class. We will define a JWTLoginFilter class that will handle the requests to the /login endpoint.\n\n\n\n\n\n\n\nIn the same HttpSecurity object we will set up the filter for the rest of the requests, to check the presence of the JWT token in the header. First we will need to create a JWTAuthenticationFilter class extending the GenericFilterBean class. Then we can add the filter to the HttpSecurity object\n\n\n\n\n\n\n\nFinally, as default users to start using the My Thai Star app we are going to define two profiles using the inMemoryAuthentication of the Spring Security framework. In the configure(AuthenticationManagerBuilder auth) method we will create:\n\n\n\n\nuser: waiter\n\n\npassword: waiter\n\n\nrole: Waiter\n\n\nuser: user0\n\n\npassword: password\n\n\nrole: Customer\n\n\n\n\n\n\n\n\n\n\nToken set up\n\nFollowing the official documentation the implementation details for the MyThaiStar’s jwt will be:\n\n\n\n\nSecret: Used as part of the signature of the token, acting as a private key. For the showcase purposes we will use simply \"ThisIsASecret\".\n\n\nToken Prefix schema: Bearer. The token will look like Bearer &lt;token&gt;\n\n\nHeader: Authorization. The response header where the token will be included. Also, in the requests, when checking the token it will be expected to be in the same header.\n\n\nThe Authorization header should be part of the Access-Control-Expose-Headers header to allow clients access to the Authorization header content (the token);\n\n\nThe claims are the content of the payload of the token. The claims are statements about the user, so we will include the user info in this section.\n\n\n\nsubject: \"sub\". The username.\n\n\nissuer: \"iss\". Who creates the token. We could use the url of our service but, as this is a showcase app, we simply will use \"MyThaiStarApp\"\n\n\nexpiration date: \"exp\". Defines when the token expires.\n\n\ncreation date: \"iat\". Defines when the token has been created.\n\n\nscope: \"scope\". Array of strings to store the user roles.\n\n\n\n\n\nSignature Algorithm: To encrypt the token we will use the default algorithm HS512.\n\n\n\n\nAn example of a token claims before encryption would be:\n\n\n{sub=waiter, scope=[ROLE_Waiter], iss=MyThaiStarApp, exp=1496920280, iat=1496916680}\n\n\n\nCurrent User request\n\nTo provide to the client with the current user data our application should expose a service to return the user details. In Devon4j applications the /general/service/impl/rest/SecurityRestServiceImpl.java class is ready to do that.\n\n\n\n\n\n\n\nwe only will need to implement the getCurrentUserDetails method.\n\n\n\nAuthorization\n\nWe need to secure three services, that only should be accessible for users with role Waiter:\n\n\n\n\n(POST) /mythaistar/services/rest/bookingmanagement/v1/booking/search.\n\n\n(POST) /mythaistar/services/rest/ordermanagement/v1/order/search.\n\n\n(POST) /mythaistar/services/rest/ordermanagement/v1/order/filter.\n\n\n\n\nAs part of the token we are providing the user Role. So, when validating the token, we can obtain that same information and build a UsernamePasswordAuthenticationToken with username and the roles as collection of Granted Authorities.\n\n\nDoing so, afterwards, in the implementation class of the logic layer we can set up the related methods with the java security '@RolesAllowed' annotation to block the access to the resource to users that does not match the expected roles.\n\n\n\n\n\n\n\n\n\n\n\n\n"}