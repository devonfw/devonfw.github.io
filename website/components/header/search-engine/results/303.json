{"type":"doc","filename":"devonfw-guide_devon4net.wiki_packages.asciidoc.html","anchor":"devonfw-guide_devon4net.wiki_packages.asciidoc_devon4net.infrastructure.jwt","title":"Devon4Net.Infrastructure.JWT","breadcrumbs":[".net","Packages","Packages"],"text":"Devon4Net.Infrastructure.JWT\n\n\nJSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA .\n\n\n— What is JSON Web Token?\n\n\n\nIn other words, a JSON Web Token is a JSON object encoded into an encrypted string that can be decoded and verified making use of cryptographic methods and algorithms. This tokens are mostly used to authenticate users in the context of websites, web applications and web services, but they can also be used to securely exchange information between parties.\n\n\nConfiguration\n\nComponent configuration is made on file appsettings.{environment}.json as follows:\n\n\n\n\n\n\n\nIn the following list all the configuration fields are described:\n\n\n\n\nAudience: Represents a valid audience that will be used to check against the token’s audience.\n\n\nIssuer: Represents a valid issuer that will be used to check against the token’s issuer.\n\n\nValidateIssuerSigningKey: Boolean that controls if validation of the SecurityKey that signed the securityToken is called.\n\n\nValidateLifetime: Boolean to control if the lifetime will be validated during token validation.\n\n\nRequireSignedTokens: Boolean that indicates wether a security token has to be signed oe not.\n\n\nRequireExpirationTime: Boolean that tells the handler if tokens need an expiration time specified or not.\n\n\nRequireAudience: Boolean that indicates tokens need to have an audience specified to be valid or not.\n\n\nClockSkew: Expiration time in minutes.\n\n\nSecurity: Certificate properties will be found in this part.\n\n\n\nSecretKeyEncryptionAlgorithm: Algorithm used to encrypt the secret key. If no argument is specified, HmacSha512 is used.\n\n\nSecretKey: Private key used to sign with the certificates. This key will be encrypted and hashed using the specified algorithm.\n\n\nCertificate: Name of certificate file or its path (if it is not in the same directory). If it doesn’t exist an exception will be raised.\n\n\nCertificatePassword: Password for the certificate selected.\n\n\nCertificateEncryptionAlgorithm: Algorithm used to encrypt the certificate. If no argument is specified, HmacSha512 is used.\n\n\nRefreshTokenEncryptionAlgorithm: Algorithm used to encrypt the refresh token. If no argument is specified, HmacSha512 is used.\n\n\n\n\n\n\n\nThere are two ways of using and creating tokens:\n\n\n\n\nSecret key: A key to encrypt and decrypt the tokens is specified. This key will be encrypted using the specified algorithm.\n\n\nCertificates: A certificate is used to manage token encryption and decryption.\n\n\n\n\n\n\n\n\n\n\nBecause the secret key takes precedence over the other option, JWT with the secret key will be used if both configurations are supplied.\n\n\n\n\n\nEncryption algorithms\n\nThe supported and tested algorithms are the following:\n\n\n\n\n\n\n\n\nAlgorithm\nValue\n\n\nHmacSha256\nHS256\n\n\nHmacSha384\nHS384\n\n\nHmacSha512\nHS512\n\n\nHmacSha256Signature\nhttp://www.w3.org/2001/04/xmldsig-more#hmac-sha256\n\n\nHmacSha384Signature\nhttp://www.w3.org/2001/04/xmldsig-more#hmac-sha384\n\n\nHmacSha512Signature\nhttp://www.w3.org/2001/04/xmldsig-more#hmac-sha512\n\n\n\n\nFor the refresh token encryption algorithm you will be able to use any algoritm from the previous table and the following table:\n\n\n\n\n\n\n\n\nAlgorithm\nValue\n\n\nMD5\nMD5\n\n\nSha\nSHA\n\n\n\n\n\n\n\n\n\n\nYou will need to specify the name of the algorithm (shown in 'algorithm' column) when configuring the component.\n\n\n\n\n\n\n\n\n\n\n\nPlease check Windows Documentation to get the latest updates on supported encryption algorithms.\n\n\n\n\n\n\n\nSetting up in Devon\n\nFor setting it up using the Devon4NetApi template configure it in the appsettings.{environment}.json file.\n\n\nYou will need to add a certificate that will be used for signing the token, please check the documentation about how to create a new certificate and add it to a project if you are not aware of how it’s done.\n\n\nRemember to configure your certificates in the JWT configuration.\n\n\nNavigate to Devon4Net.Application.WebAPI.Implementation.Business.AuthManagement.Controllers. There you will find AuthController sample class which is responsible of generating the token thanks to login method.\n\n\n\n\n\n\n\nYou can see how the IJwtHandler is injected in the constructor via its interface, which allows you to use its methods.\n\n\nIn the following piece of code, you will find how the client token is created using a variety of claims. In this case this end-point will be available to not identified clients thanks to the AllowAnonymous attribute. The client will also have a sample role asigned, depending on which it will be able to access some end-points and not others.\n\n\n\n\n\n\n\nThe following example will require clients to have the sample role to be able to use the end-point, thanks to the attribute Authorize with the Roles value specified.\n\n\nIt also shows how you can obtain information directly from the token using the JwtHandler injection.\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlease check devon documentation of Security and Roles to learn more about method attributtes.\n\n\n\n\n\n\nSetting up in other projects\n\nInstall the package on your solution using the Package Manager Console:\n\n\n\n\n\n\n\nConfigure swagger in Program.cs adding the following lines:\n\n\n\n\n\n\n\nAt this moment you’ll need to have at least one certificate added to your project.\n\n\n\n\n\n\n\n\nPlease read the documentation of how to create and add certificates to a project.\n\n\n\n\n\nNow we will configure the JWT component in appsettings.{environment}.json as shown in the next piece of code:\n\n\n\n\n\n\n\nFor using it, you will need a method that provides you a token. So lets create an AuthController controller and add those methods:\n\n\n\n\n\n\n\nReading the code of this controller you have to take in mind a few things:\n\n\n\n\nIJwtHandler class is injected via dependency injection.\n\n\n\nstring CreateClientToken(List&lt;Claim&gt; list) will allow you to create the token through a list of claims. The claims shown are hard-coded examples.\n\n\nList&lt;Claim&gt; GetUserClaims(string token) will allow you to get a list of claims given a token.\n\n\nstring GetClaimValue(List&lt;Claim&gt; list, string claim) will allow you to get the value given the ClaimType and either a list of claims or a token thanks to the string GetClaimValue(string token, string claim) overload.\n\n\n\n\n\n[AllowAnonymous] attribute will allow access any client without authentication.\n\n\n[Authorize(AuthenticationSchemes = \"Bearer\", Roles = \"MyRole\")] attribute will allow any client authenticated with a bearer token and the role \"MyRole\".\n\n\n\n\n\nReferences\n\n\n\nTokenValidationParameterClass - Microsoft Docs\n\n\nAttributtes in C# - Microsoft Docs\n\n\nAlgorithms supported\n\n\n\n\n\n\n"}