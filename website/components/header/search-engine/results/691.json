{"type":"doc","filename":"devonfw-guide_hangar.wiki_hangar.asciidoc_github-actions-deploying-on-aws-eks-or-azure-aks.html","anchor":"devonfw-guide_hangar.wiki_hangar.asciidoc_setup-github-workflows","title":"Setup Github Workflows","breadcrumbs":["CI/CD","devonfw Hangar","GitHub Actions deploying on AWS EKS or Azure AKS"],"text":"Setup Github Workflows\n\nSetting up a Build workflow on GitHub\n\nIn this section we will create a build workflow for compiling project code. This workflow will be configured to be executed as a job inside a CI workflow, regardless of which branch it is made on.\n\n\nThe creation of the GitHub action will follow the project workflow, so a new branch named feature/build-pipeline will be created and the YAML file for the workflow will be pushed to it.\n\n\nThen, a Pull Request (PR) will be created in order to merge the new branch into the appropriate branch (provided in -b flag). The PR will be automatically merged if the repository policies are met. If the merge is not possible, either the PR URL will be shown as output, or it will be opened in your web browser if using -w flag.\n\n\nThe script located at /scripts/pipelines/github/pipeline_generator.sh will automatically create this new branch, create a build workflow based on a YAML template appropriate for the project programming language or framework, create the Pull Request and, if it is possible, merge this new branch into the specified branch.\n\n\nPlease note that this workflow, although manually triggerable, is designed to be executed as part of a CI workflow, which you can create following this guide.\n\n\nPrerequisites\n\nThis script will commit and push the corresponding YAML template into your repository, so please be sure your local repository is up-to-date (i.e you have pulled latest changes with git pull).\n\n\n\n== Creating the workflow using provided script\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\n\n\nThe config file for the build workflow is located at /scripts/pipelines/github/templates/build/build-pipeline.cfg.\n\n\n\n\n\n\nFlags\n\n\n\n\n\n\n\nExamples\n\nQuarkus project\n\nQuarkus native project\n\n\n\n\n\n\n\nQuarkus project using JVM\n\n\n\n\n\n\n\n\nNode.js project\n\n\n\n\n\n\n\nAngular project\n\n\n\n\n\n\n\n\n\n\n\nSetting up a Test workflow on GitHub\n\nIn this section we will create a test workflow on GitHub for running project test cases. This workflow will be configured to be executed as a job inside a CI workflow after the build job, and consumes the artifact produced by the build workflow.\n\n\nThe creation of this GitHub action will follow the project workflow, so a new branch named feature/test-pipeline will be created and the YAML file for the workflow will be pushed to it.\n\n\nThen, a Pull Request (PR) will be created in order to merge the new branch into the appropriate branch (provided in -b flag). The PR will be automatically merged if the repository policies are met. If the merge is not possible, either the PR URL will be shown as output, or it will be opened in your web browser if using -w flag.\n\n\nThe script located at /scripts/pipelines/github/pipeline_generator.sh will automatically create new branch, create a test workflow based on a YAML template appropriate for the project programming language or framework, create the Pull Request, and if it is possible, merge this new branch into the specified branch.\n\n\nPlease note that this workflow, although manually triggerable, is designed to be executed as part of a CI workflow, which you can create following this guide.\n\n\nPrerequisites\n\n\n\nThis script will commit and push the corresponding YAML template into your repository, so please be sure your local repository is up-to-date (i.e you have pulled latest changes with git pull).\n\n\n[Optional] Having some knowledge about the application, in particular knowing if, when tested, it produces a log file or some other blob (e.g. performance profiling data) interesting to be kept as an artifact.\n\n\n\n\n\n== Creating the workflow using provided script\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\n\n\nThe config file for the test workflow is located at /scripts/pipelines/github/templates/test/test-pipeline.cfg.\n\n\n\n\n\n\nFlags\n\n\n\n\n\n\n\nExamples\n\nQuarkus project\n\nQuarkus native project\n\n\n\n\n\n\n\nQuarkus project using JVM\n\n\n\n\n\n\n\n\nNode.js project\n\n\n\n\n\n\n\nAngular project\n\n\n\n\n\n\n\n\n\n\n\nQuality pipeline\n\nSetting up a SonarQube instance in AWS\n\nThe scope of this section is to deploy an AWS EC2 instance running SonarQube for further usage from a CI pipeline. A set of scripts and a Terraform recipe have been created in order to assist you in the launch of a SonarQube instance with an embedded database.\n\n\nGetting Started\n\nPrerequisites\n\n\n\nInstall Terraform.\n\n\nInstall AWS CLI.\n\n\nHave a SSH keypair for the SonarQube instance. You can use an existing one or create a new one with the following command:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis will create a public key, directly stored in AWS (current region only), and a private key stored in the sonarqube.pem file, that will be necessary if you ever need to access the instance, so be sure you store it securely.\n\n\n\n\n\n\nRelevant files\n\n\n\nmain.tf contains declarative definition written in HCL of AWS infrastructure.\n\n\nsetup_sonarqube.sh script to be run on EC2 instance that installs and deploys a container running SonarQube.\n\n\nvariables.tf contains variable definition for main.tf.\n\n\nterraform.tfvars contains values (user-changeable) for the variables defined in variables.tf.\n\n\nterraform.tfstate contains current state of the created infrastructure. Should be stored securely.\n\n\nset-terraform-variables.sh assists user in setting the values of terraform.tfvars.\n\n\n\n\n\n\nUsage\n\nFirst, you need to initialize the working directory containing Terraform configuration files (located at /scripts/sonarqube) and install any required plugins:\n\n\n\n\n\n\n\nThen, you may need to customize some input variables about the environment. To do so, you can either edit terraform.tfvars file or take advantage of the set-terraform-variables script, which allows you to create or update values for the required variables, passing them as flags. As a full example:\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnless changed, the keypair name expected by default is sonarqube.\n\n\n\n\n\nFinally, deploy SonarQube instance:\n\n\n\n\n\n\n\n\n\n\n\n\n\nterraform apply command performs a plan and actually carries out the planned changes to each resource using the relevant infrastructure provider’s API. You can use it to perform changes on the created resources later on. Remember to securely store terraform.tfstate file, otherwise you will not be able to perform any changes, including detroying them, from Terraform. More insights here.\n\n\n\n\n\nIn particular, this will create an Ubuntu-based EC2 instance in AWS and deploy a Docker container running SonarQube.\n\n\nYou will get the public IP address of the EC2 instance as output. Take note of it, you will need it later on.\n\n\nAfter a few minutes, you will be able to access SonarQube web interface on http://sonarqube_public_ip:9000 (replace with actual IP) with the following credentials:\n\n\n\n\nUsername:   admin\n\n\nPassword:   admin\n\n\n\n\n\n\n\n\n\n\nChange the default password promptly.\n\n\n\n\n\n\nAppendix: Destroy SonarQube instance\n\nAs long as you keep the terraform.tfstate file generated when creating the SonarQube instance, you can easily destroy it and all associated resources by executing:\n\n\n\n\n\n\n\n\n\n\nSetting up a Quality workflow on GitHub\n\nIn this section we will create a quality workflow for analyzing project code with SonarQube. This workflow will be configured to be executed as a job inside a CI workflow after the test (or build, if no test) job, and consumes the artifact produced by the build workflow.\n\n\nThe creation of this GitHub action will follow the project workflow, so a new branch named feature/quality-pipeline will be created and the YAML file for the workflow will be pushed to it.\n\n\nThen, a Pull Request (PR) will be created in order to merge the new branch into the appropriate branch (provided in -b flag). The PR will be automatically merged if the repository policies are met. If the merge is not possible, either the PR URL will be shown as output, or it will be opened in your web browser if using -w flag.\n\n\nThe script located at /scripts/pipelines/github/pipeline_generator.sh will automatically create this new branch, create a quality workflow based on a YAML template appropriate for the project programming language or framework, create the Pull Request, and if it is possible, merge this new branch into the specified branch.\n\n\nPlease note that this workflow, although manually triggerable, is designed to be executed as part of a CI workflow, which you can create following this guide.\n\n\nPrerequisites\n\n\n\nThis script will commit and push the corresponding YAML template into your repository, so please be sure your local repository is up-to-date (i.e you have pulled the latest changes with git pull).\n\n\nGenerate a SonarQube token (just follow the section \"Generating a token\").\n\n\n\n\n\n== Creating the workflow using provided script\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\n\n\nThe config file for the quality workflow is located at /scripts/pipelines/github/templates/quality/quality-pipeline.cfg.\n\n\n\n\n\n\nFlags\n\n\n\n\n\n\n\nExamples\n\nQuarkus project\n\n\n\n\n\n\n\nNode.js project\n\n\n\n\n\n\n\nAngular project\n\n\n\n\n\n\n\n\n\n\n\n\nSetting up a CI workflow on GitHub\n\nIn this section we will create a CI workflow for the project. This workflow will be configured to be triggered every time there is a commit to the GitHub repository, regardless of which branch it is made on. This CI workflow will execute the build workflow, and depending on the flags given, also the test and quality workflows, as its jobs.\n\n\nThe creation of the GitHub action will follow the project workflow, so a new branch named feature/ci-pipeline will be created and the YAML file for the workflow will be pushed to it.\n\n\nThen, a Pull Request (PR) will be created in order to merge the new branch into the appropriate branch (provided in -b flag). The PR will be automatically merged if the repository policies are met. If the merge is not possible, either the PR URL will be shown as output, or it will be opened in your web browser if using -w flag.\n\n\nThe script located at /scripts/pipelines/github/pipeline_generator.sh will automatically create this new branch, create a CI workflow based on a YAML template, create the Pull Request and, if it is possible, merge this new branch into the specified branch.\n\n\nPrerequisites\n\n\n\nThis script will commit and push the corresponding YAML template into your repository, so please be sure your local repository is up-to-date (i.e you have pulled latest changes with git pull).\n\n\nAn existing build workflow.\n\n\n[Optional] An existing test workflow.\n\n\n[Optional] An existing quality workflow.\n\n\n\n\n\nCreating the workflow using provided script\n\nUsage\n\n\n\n\n\n\n\n\n\n\n\n\nThe config file for the CI workflow is located at /scripts/pipelines/github/templates/ci/ci-pipeline.cfg.\n\n\n\n\n\n\nFlags\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\nApp Package pipeline\n\n\nSetup Container Image Registry\n\nThe scope of this section is to setup/create a container image registry or repository (depending on provider) on Docker Hub, AWS or Azure for allowing the pipeline that will package the application to push the resulting container image. By the end of this guide, we will get as an output the container repository URI, and, for some providers, the credentials for accessing the registry.\n\n\nA container image name generically has the following format:\n\n\n\n\n&lt;registry-url&gt;/&lt;namespace&gt;/&lt;image-name&gt;:&lt;tag&gt;\n\n\n\n&lt;registry-url&gt;: Container registry URL based on registry provider.\n\n\n&lt;namespace&gt;: Namespace within which the image is located.\n\n\n&lt;image-name&gt;: Repository/image name which can be from one level to n-level deep (depending on provider).\n\n\n&lt;tag&gt;: Some alphanumeric tag which is given as identifier.\n\n\n\n\n\n\n\n\nDocker Hub\n\nPrerequisites\n\n\n\nDocker Hub account is required to access Docker Hub Registry. You can create one here.\n\n\n\n\n\nCreating an image repository\n\n\n\nLogin on Docker Hub website.\n\n\nGo to Repositories tab and click on \"Create Repository\".\n\n\nProvide Name and Visibility for the repository and click \"Create\" button.\n\n\n\n\n\nImage Format\n\n\n\n\n\n\n\nFor referencing an image in Docker Hub, you don’t have to specify the &lt;registry-url&gt; since it is the default on Docker.\nIMPORTANT: Docker Hub does not support multi-level image names.\n\n\n\n\n\n\n\n&lt;namespace&gt;/&lt;image-name&gt;:&lt;tag&gt;\n\n\n\n&lt;namespace&gt;: Username or Organization on Docker Hub.\n\n\n&lt;image-name&gt;: Previously chosen repository name.\n\n\n&lt;tag&gt;: Some alphanumeric tag which is given as identifier.\n\n\n\n\n\n\n\nExamples\n\n\n\ndevonfw/my-thai-star-angular:latest\n\n\ndevonfw/my-thai-star-java:1.5\n\n\ndevonfw/devon4quarkus-reference:2.0\n\n\n\n\n\n\n\nAWS Elastic Container Registry\n\nPrerequisites\n\n\n\nAn AWS account.\n\n\nAWS CLI installed.\n\n\n\n\n\nCreating an image repository namespace\n\n\n\nGet the AWS Account ID by executing aws sts get-caller-identity.\n\n\nLogin to AWS ECR with the following command (an example &lt;region&gt; would be eu-west-1):\n\n\n\n\n\n\n\n\n\n\n\nCreate a repository namespace with the following command:\n\n\n\n\n\n\n\n\n\nSample Output\n\n\n\n\n\n\n\n\nImage Format\n\n\n\n&lt;registry-url&gt;/&lt;namespace&gt;/&lt;image-name&gt;:&lt;tag&gt;\n\n\n\n&lt;registry-url&gt;: &lt;aws-account-id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com\n\n\n&lt;namespace&gt;: Previously chosen repository name.\n\n\n&lt;image-name&gt;: Freely chosen project/image-name given by the user.\n\n\n&lt;tag&gt;: Some alphanumeric tag which is given as identifier.\n\n\n\n\n\n\n\nThat is:\n\n\n\n\n&lt;aws-account-id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/&lt;repository-name&gt;/&lt;image-name&gt;:&lt;tag&gt;\n\n\n\n\nExamples\n\n\n\n1000000001.dkr.ecr.eu-west-1.amazonaws.com/devonfw/my-thai-star-angular:latest\n\n\n1000100001.dkr.ecr.us-east-1.amazonaws.com/devonfw/my-thai-star/angular:1.5\n\n\n1000200001.dkr.ecr.ap-south-1.amazonaws.com/devonfw/quarkus/sample/devon4quarkus-reference:2.0\n\n\n\n\n\n\n\nAzure Container Registry\n\nPrerequisites\n\n\n\nAn Azure account with active subscription.\n\n\nAn Azure resource group.\n\n\nAzure CLI installed.\n\n\n\n\n\nCreating an image registry\n\n\n\nLogin to Azure using az login.\n\n\nSet the Azure Subscription using az account set --subscription &lt;mySubscription&gt;.\n\n\nCreate a registry with the following command:\n\n\n\n\n\n\n\n\n\nSample Output\n\n\n\n\n\n\n\n\n\nEnable user and password authentication on the registry with the following command:\n\n\n\n\n\n\n\n\n\n\nAny authentication option that produces as a result a long-term user and password is valid. The least troublesome one follows.\n\n\n\n\n\n\n\n\n\n\n\n\nRetrieve credentials for accessing the registry with the following command:\n\n\n\n\n\n\n\n\n\n\nImage Format\n\n\n\n&lt;registry-url&gt;/&lt;namespace&gt;/&lt;image-name&gt;:&lt;tag&gt;\n\n\n\n&lt;registry-url&gt;: &lt;registry-name&gt;.azurecr.io\n\n\n&lt;namespace&gt;/&lt;image-name&gt;: Freely chosen project/image-name given by the user.\n\n\n&lt;tag&gt;: Some alphanumeric tag which is given as identifier.\n\n\n\n\n\n\n\nThat is:\n\n\n\n\n&lt;registry-name&gt;.azurecr.io/&lt;namespace&gt;/&lt;image-name&gt;:&lt;tag&gt;\n\n\n\n\nExamples\n\n\n\ndevonacr.azurecr.io/devonfw/my-thai-star-angular:latest\n\n\ndevonacr.azurecr.io/devonfw/my-thai-star/angular:1.5\n\n\ndevonacr.azurecr.io/devonfw/quarkus/sample/devon4quarkus-reference:2.0\n\n\n\n\n\n\n\nProvider Documentation\n\n\n\nDocker Hub\n\n\nAWS ECR\n\n\nAzure ACR\n\n\n\n\n\n\nSetting up a Package workflow on GitHub\n\nIn this section we will create a package workflow to build and push a container image of the project application into the specified container registry. This workflow will be configured in order to be triggered every time CI workflow is executed successfully on a commit for release/* and develop branches, requiring manual launch for other branches but still enforcing that CI workflow has passed. It consumes the artifact produced by the build workflow.\n\n\nThe creation of the GitHub action will follow the project workflow, so a new branch named feature/package-pipeline will be created and the YAML file for the workflow will be pushed to it.\n\n\nThen, a Pull Request (PR) will be created in order to merge the new branch into the appropriate branch (provided in -b flag). The PR will be automatically merged if the repository policies are met. If the merge is not possible, either the PR URL will be shown as output, or it will be opened in your web browser if using -w flag.\n\n\nThe script located at /scripts/pipelines/github/pipeline_generator.sh will automatically create this new branch, create a package workflow based on a YAML template, create the Pull Request and, if it is possible, merge this new branch into the specified branch.\n\n\nPrerequisites\n\nThis script will commit and push the corresponding YAML template into your repository, so please be sure your local repository is up-to-date (i.e you have pulled latest changes with git pull).\n\n\n\n== Creating the workflow using provided script\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\n\n\nThe config file for the package workflow is located at /scripts/pipelines/github/templates/package/package-pipeline.cfg.\n\n\n\n\n\n\nFlags\n\n\n\n\n\n\n\nExamples\n\nQuarkus project\n\n"}