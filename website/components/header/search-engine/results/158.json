{"type":"doc","filename":"devonfw-guide_devon4j.wiki_guide-jpa.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_guide-jpa.asciidoc_inheritance","title":"Inheritance","breadcrumbs":["Java","General","Java Persistence API"],"text":"Inheritance\n\n\n\n\nWarning\n\n\nHey there! Seems like you are still using the documentation of our legacy Java repository. Since it wonâ€™t be maintained anymore, we recommend you to checkout the new Java page here.\nJust like normal java classes, entity classes can inherit from others. The only difference is that you need to specify how to map a class hierarchy to database tables. Generic abstract super-classes for entities can simply be annotated with @MappedSuperclass.\n\n\n\n\n\nFor all other cases the JPA offers the annotation @Inheritance with the property strategy talking an InheritanceType that has the following options:\n\n\n\n\n\n\nSINGLE_TABLE: This strategy uses a single table that contains all columns needed to store all entity-types of the entire inheritance hierarchy. If a column is not needed for an entity because of its type, there is a null value in this column. An additional column is introduced, which denotes the type of the entity (called dtype).\n\n\nTABLE_PER_CLASS: For each concrete entity class there is a table in the database that can store such an entity with all its attributes. An entity is only saved in the table corresponding to its most concrete type. To get all entities of a super type, joins are needed.\n\n\nJOINED: In this case there is a table for every entity class including abstract classes, which contains only the columns for the persistent properties of that particular class. Additionally there is a primary key column in every table. To get an entity of a class that is a subclass of another one, joins are needed.\n\n\n\n\n\n\nEach of the three approaches has its advantages and drawbacks, which are discussed in detail here. In most cases, the first one should be used, because it is usually the fastest way to do the mapping, as no joins are needed when retrieving, searching or persisting entities. Moreover it is rather simple and easy to understand.\nOne major disadvantage is that the first approach could lead to a table with a lot of null values, which might have a negative impact on the database size.\n\n\nThe inheritance strategy has to be annotated to the top-most entity of the class hierarchy (where @MappedSuperclass classes are not considered) like in the following example:\n\n\n\n\n\n\n\nAs a best practice we advise you to avoid entity hierarchies at all where possible and otherwise to keep the hierarchy as small as possible. In order to just ensure reuse or establish a common API you can consider a shared interface, a @MappedSuperclass or an @Embeddable instead of an entity hierarchy.\n\n\n\n"}